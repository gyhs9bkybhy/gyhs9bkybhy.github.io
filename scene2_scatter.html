<!Doctype html>
<html>
    <head>
        <title> Narrative Visualization</title>
        <script src = 'https://d3js.org/d3.v5.min.js'> </script>
    </head>

    <body>
        <button id = 'switch' onclick="location.href='scene1_timeline.html'" type="button"> Previous Page </button>
        <svg id = 'mainsvg' width = '1000' height = '800'></svg>
        <script>

            // Some parameters 
            var g_scatter, g_country;
            const margin = {top: 100, left: 50, bottom: 50, right: 50};
            const svgwidth = d3.select('#mainsvg').attr('width');
            const svgheight = d3.select('#mainsvg').attr('height');
            const innerwidth = svgwidth - margin.left - margin.right;
            const innerheight = svgheight - margin.top - margin.bottom;
            var xScale, yScale;
            const duration = 50; // set the duration of transition to 100ms

            let alldata = [];
            let date_lst = [];
            let country_lst = []

            const tooltip = d3.select('body').append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0)
                .style('position', 'absolute');

            // This is the function for initialization
            const renderInit = function(data){

                let firstday = date_lst[0];
                xScale = d3.scaleLog()
                .domain([1, d3.max(data, d => d.Confirmed[date_lst.length - 1])])
                .range([0, innerwidth]);

                yScale = d3.scaleLog()
                .domain([d3.max(data, d => d.Death[date_lst.length - 1]), 1])
                .range([0, innerheight]);
 
                let xAxis = d3.axisBottom(xScale);
                let yAxis = d3.axisLeft(yScale);

                g_scatter = d3.select('#mainsvg')
                .append('g')
                    .attr('id', 'scatterplot')
                    .attr('transform', `translate(${margin.left}, ${margin.top})`);
                
                g_scatter.append('text')
                .attr('id', 'date_text')
                .text(date_lst[0].toLocaleDateString());

                data = data.filter(d => (d.Confirmed[0] !== 0 && d.Death[0] !== 0))


                g_scatter.selectAll('circle')
                .data(data, d => d.Country)
                .enter()
                .append('circle')
                    .attr('cx', d => xScale(d.Confirmed[0]))
                    .attr('cy', d => yScale(d.Death[0]))
                    .attr('r', 5)
                    .attr('fill', 'dodgerblue')
                    .on('mouseover', function(d){
                        const tiptext = 'Country: ' + d.Country
                        + '<br>' + 'Confirmed: ' + d.Confirmed[0].toString()
                        + '<br>' + 'Death: ' + d.Death[0].toString();
                            // raise the tooltip around the mouse
                        tooltip.html(tiptext)
                        .style('opacity', 1)
                        .style('top', (event.pageY - 30) + 'px')
                        .style('left', (event.pageX) + 'px');

                        d3.select(this)
                        .attr('fill', 'red')
                        .attr('r', 8)
                        .style('opacity', 0.5);
                    })
                    .on('mouseout', function(d){

                        // raise the tooltip around the mouse
                        tooltip.style('opacity', 0);

                        d3.select(this)
                        .attr('fill', 'dodgerblue')
                        .attr('r', 5)
                        .style('opacity', 1);
                    });

            
                let g_xAxis = g_scatter.append('g').call(xAxis)
                .attr('id', 'xaxis')
                .attr('transform', `translate(0, ${innerheight})`);

                let g_yAxis = g_scatter.append('g').call(yAxis)
                .attr('id', 'yaxis')

            }

            const renderUpdate = function(data, date_idx){

                // select the scatter plot
                g_scatter = d3.select('#scatterplot');

                data = data.filter(d => (d.Confirmed[date_idx] !== 0 && d.Death[date_idx] !== 0))

                // update every date
                let circleupdate = g_scatter.selectAll('circle')
                .data(data, d => d.Country); // assign a key for matching when updated
                

                let circleenter = circleupdate.enter()
                .append('circle')
                    .attr('cx', d => xScale(d.Confirmed[date_idx]))
                    .attr('cy', d => yScale(d.Death[date_idx]))
                    .attr('r', 5)
                    .attr('fill', 'dodgerblue');

                
                circleupdate.merge(circleenter)
                .transition().duration(duration)
                .attr('cx', d => xScale(d.Confirmed[date_idx]))
                .attr('cy', d => yScale(d.Death[date_idx]))

                g_scatter.selectAll('circle')
                .on('mouseover', function(d){

                    const tiptext = 'Country: ' + d.Country
                        + '<br>' + 'Confirmed: ' + d.Confirmed[date_idx].toString()
                    + '<br>' + 'Death: ' + d.Death[date_idx].toString();

                    // raise the tooltip around the mouse
                    // AN ISSUE HERE: sometimes the mouse is an arrow, other time the cursor(text selection)
                    // Solution: 1.this is because when mouseout, the text still there just transparent, we should make the text = ''
                    // 2. when mouseover, the text can be wide and high, so the text cover the arrow, we should set the top, left attribute to make the text away from mouse
                    tooltip.html(tiptext)
                    .style('opacity', 1)
                    .style('top', (event.pageY - 100) + 'px')
                    .style('left', (event.pageX - 100) + 'px'); 


                    d3.select(this)
                    .attr('fill', 'red')
                    .attr('r', 8)
                    .style('opacity', 0.5);
                    })
                .on('mouseout', function(d){

                    // raise the tooltip around the mouse
                    tooltip.html('')
                    .style('opacity', 0);

                    d3.select(this)
                    .attr('fill', 'dodgerblue')
                    .attr('r', 5)
                    .style('opacity', 1);
                    })  
                .on('click', function(d){
                    g_scatter.style('visibility', 'hidden');
                    scene3(d.Country);
                });


                g_scatter.selectAll('#date_text').remove();
                g_scatter.append('text')
                .attr('id', 'date_text')
                .text(date_lst[date_idx]);
                    
                            
            }

            async function scene3(country){


                // retrieve the data of the country, we need to reconstruct to make it an array
                let country_rawdata = alldata[country_lst.indexOf(country)];
                let countrydata = [];
                let i;
                for (i = 0; i < country_rawdata.Confirmed.length; i++){
                    let newitem = {'date': date_lst[i], 
                                'confirmed': country_rawdata.Confirmed[i],
                                'death': country_rawdata.Death[i]};
                    countrydata.push(newitem);
                }

                // xscale is for date
                let country_xScale = d3.scaleTime()
                .domain(d3.extent(countrydata, d => d.date))
                .range([0, innerwidth]);

                // yscale is for total confirmed cases in the world
                let country_yScale = d3.scaleLinear()
                .domain([0, d3.max(countrydata, d => d.confirmed)].reverse())
                .range([0, innerheight]);

                // here is another new scale for the bars for display
                let barScale = d3.scaleBand()
                .domain(countrydata.map(d => d.date))
                .range([0, innerwidth]);

                // add the country group
                g_country = d3.select('#mainsvg')
                .append('g')
                    .attr('id', 'g_country')
                    .attr('transform', `translate(${margin.left}, ${margin.top})`);

                g_country.append('text')
                .attr('id', 'country_text')
                .text(country.toString());                    

                let country_xAxis = d3.axisBottom(country_xScale);
                let country_yAxis = d3.axisLeft(country_yScale);

                let g_xAxis = g_country.append('g').call(country_xAxis)
                .attr('id', 'country_xaxis')
                .attr('transform', `translate(0, ${innerheight})`);

                let g_yAxis = g_country.append('g').call(country_yAxis)
                .attr('id', 'country_yaxis');

                let confirmed_linefunc = d3.line()
                .x(d => country_xScale(d.date))
                .y(d => country_yScale(d.confirmed));

                let confirmed_line = g_country.append('path')
                .attr('id', 'confirmed_line')
                .datum(countrydata)
                .attr('d', confirmed_linefunc)
                .attr('stroke', 'steelblue')
                .attr("stroke-width", 1.5)
                .attr("stroke-linejoin", "round")
                .attr("stroke-linecap", "round")
                .attr('fill', 'none')
                .style('opacity', 0.8);

                const tooltip = d3.select('body').append('div')
                    .attr('class', 'tooltip')
                    .style('opacity', 0)
                    .style('position', 'absolute');

                // now what i want is vanoid, when every point relates to a opaque bar for selection
                g_country.selectAll('rect')
                    .data(countrydata)
                    .enter()
                    .append('rect')
                        .attr('x', d => country_xScale(d.date) - 0.49 * barScale.bandwidth())
                        .attr('y', 0)
                        .attr('width', 5 * barScale.bandwidth())
                        .attr('height', innerheight)
                        .attr('fill', 'red')
                        .style('opacity', 0)
                        .on('mouseover', function(d) { // pay attention => can't define this, has be to function(d)
                            d3.select(this)
                            .style('opacity', 0.3);
                            
                            // the text for tooptip: date & total cases
                            const tiptext = 'Date: ' + d.date.toLocaleDateString() + '<br>' + 'Total Cases: ' + d.confirmed.toString();
                            // raise the tooltip around the mouse
                            tooltip.html(tiptext)
                            .style('opacity', 1)
                            .style('top', (event.pageY - 100) + 'px')
                            .style('left', (event.pageX - 100) + 'px');
                            

                        })
                        .on('mouseout', function(d) {
                            d3.select(this)
                            .style('opacity', 0);

                            tooltip.html('')
                            .style('opacity', 0);

                        });
                document.getElementById('switch').onclick = switchfrom3to2;
            };

            async function scene2(){
                
                // Load the confirmed data
                let load_confirmed = await d3.csv("confirmed.csv").then(data => {
                    console.log(data);
                    date_lst = Object.keys(data[0]).slice(3); // store the dates in a list 
                    date_lst = date_lst.map(d => new Date(d));
                    
                    data.forEach(d => {

                        let newcountry = {};
                        newcountry['Confirmed'] = Object.values(d).slice(3).map(d => +(d));
                        newcountry['Country'] = d['Country/Region'];
                        alldata.push(newcountry); //remember push rather than append in js

                    
                    });
                    country_lst = alldata.map(d => d.Country);
                });
                
                // Load the death data
                let load_death = await d3.csv('death.csv').then(data => {
                    let idx = 0;
                    data.forEach(d => {

                        alldata[idx]['Death'] = Object.values(d).slice(3).map(d => +(d));
                        idx += 1;

                    });
                });

                renderInit(alldata);
                let idx = 1;

                let interval = setInterval(() => {
                    if (idx >= date_lst.length){
                        clearInterval(interval);
                    }
                    else{
                        renderUpdate(alldata, idx);
                        idx += 1;
                        console.log(date_lst[idx])
                    }
                    
    
                }, duration);


            };

            const switchfrom3to2 = function(){
                g_scatter.style('visibility', 'visible');
                g_country.style('visibility', 'hidden');
                document.getElementById('switch').onclick = function(){location.href='scene1_timeline.html'};
                
            };
            
            scene2();

            
        </script>
    </body>
</html>